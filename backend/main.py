import sys
import asyncio

if sys.platform == "win32":
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

from fastapi import FastAPI, UploadFile, Form, Depends, HTTPException, status, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.security import OAuth2PasswordBearer
from PIL import Image
import io, json, os, uuid
import base64
from typing import Optional, List

from generate_creatives import generate_all
from database import db
from models import UserCreate, UserLogin, UserModel, Token
from auth import verify_password, get_password_hash, create_access_token, get_current_user

app = FastAPI()

# ---------------- CORS ----------------
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------------- STATIC FILES ----------------
os.makedirs("assets/generated", exist_ok=True)
app.mount("/static", StaticFiles(directory="assets/generated"), name="static")

# ---------------- AUTH ROUTES ----------------
@app.post("/register")
async def register(user: UserCreate):
    existing_user = await db.users.find_one({"email": user.email})
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    hashed_password = get_password_hash(user.password)
    user_dict = user.dict()
    user_dict["hashed_password"] = hashed_password
    del user_dict["password"]
    user_dict["colors"] = []
    
    new_user = await db.users.insert_one(user_dict)
    return {"message": "User created successfully", "id": str(new_user.inserted_id)}

@app.post("/login", response_model=Token)
async def login(user: UserLogin):
    db_user = await db.users.find_one({"email": user.email})
    if not db_user or not verify_password(user.password, db_user["hashed_password"]):
        raise HTTPException(status_code=401, detail="Incorrect email or password")
    
    access_token = create_access_token(data={"sub": user.email})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=UserModel)
async def read_users_me(current_user: UserModel = Depends(get_current_user)):
    return current_user

@app.post("/colors")
async def add_color(color: str = Form(...), current_user: UserModel = Depends(get_current_user)):
    # Avoid duplicates
    if color not in current_user.colors:
        await db.users.update_one(
            {"_id": current_user.id},
            {"$push": {"colors": color}}
        )
    return {"message": "Color added", "colors": current_user.colors + [color] if color not in current_user.colors else current_user.colors}

@app.get("/cloud-images")
async def get_cloud_images(current_user: UserModel = Depends(get_current_user)):
    # Retrieve images generated by this user
    # We need to store them in DB first. Let's say collection 'images'
    cursor = db.images.find({"user_id": str(current_user.id)})
    images = await cursor.to_list(length=100)
    # Convert ObjectId to str
    for img in images:
        if "_id" in img:
            img["_id"] = str(img["_id"])
    return images

# ---------------- EXTRACT ----------------
@app.post("/extract")
async def extract(
    main_message: str = Form(...),
    sub_message: str = Form(...),
    cta_text: str = Form(...),
    style: str = Form("clean"),
    background_color: str = Form(None),
    badge_color: str = Form(None),
    badge_shape: str = Form(None),
):
    spec = {
        "main_message": main_message.strip(),
        "sub_message": sub_message.strip(),
        "cta_text": cta_text.strip(),
        "style": style.strip() or "clean",
        "background_color": background_color.strip() if background_color else None,
        "badge_color": badge_color.strip() if badge_color else None,
        "badge_shape": badge_shape.strip() if badge_shape else None,
    }
    return spec


# ---------------- GENERATE IMAGES ----------------
@app.post("/generate-images")
async def generate_images(
    spec: str = Form(...),
    product_image: UploadFile = Form(...),
    logo_image: UploadFile = Form(...),
    authorization: Optional[str] = Header(None) # Manual token extraction for mixed usage
):
    spec_dict = json.loads(spec)

    # Read Images
    product_bytes = await product_image.read()
    logo_bytes = await logo_image.read()
    
    product = Image.open(io.BytesIO(product_bytes)).convert("RGBA")
    logo = Image.open(io.BytesIO(logo_bytes)).convert("RGBA")

    # Generate for the REQUESTED spec (immediate return)
    primary_outputs = generate_all(
        spec=spec_dict,
        product=product,
        logo=logo,
    )

    # ---------------- DYNAMIC CLOUD GENERATION ----------------
    # Check if user is authenticated
    user = None
    if authorization:
        try:
            scheme, param = authorization.split()
            if scheme.lower() == 'bearer':
                user = await get_current_user(param)
        except Exception:
            pass # Invalid token, ignore
    
    if user:
        # User is logged in. 
        # Requirement: "generated from all that colors stored... viewd in cloud url"
        stored_colors = user.colors
        
        # Also include the current requested color if not in stored? 
        # Requirement says "generated from all that colors stored".
        # We'll iterate through stored colors.
        # Combine stored colors with the current requested color to ensure cloud history is populated
        unique_colors = set(stored_colors)
        current_bg = spec_dict.get("background_color")
        if current_bg:
            unique_colors.add(current_bg)
        
        print(f"DEBUG: User {user.email} found. Generataing for colors: {unique_colors}")
        
        for color in unique_colors:
            # Create a localized spec
            color_spec = spec_dict.copy()
            color_spec["background_color"] = color
            
            # Generate
            color_outputs = generate_all(color_spec, product, logo)
            
            # Save to disk and DB
            for fmt, b64_data in color_outputs.items():
                # Decode
                img_data = base64.b64decode(b64_data)
                filename = f"{user.id}_{uuid.uuid4()}.png"
                path = os.path.join("assets", "generated", filename)
                
                with open(path, "wb") as f:
                    f.write(img_data)
                
                # Save metadata to DB
                await db.images.insert_one({
                    "user_id": str(user.id),
                    "url": f"http://127.0.0.1:8000/static/{filename}",
                    "format": fmt,
                    "color": color,
                    "spec": color_spec
                })

    return primary_outputs
