import sys
import asyncio

if sys.platform == "win32":
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

from fastapi import FastAPI, UploadFile, Form, Depends, HTTPException, status, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.security import OAuth2PasswordBearer
from PIL import Image
import io, json, os, uuid
import base64
from typing import Optional, List

from generate_creatives import generate_all
from ai_agent import generate_ad_image
from database import db
from models import UserCreate, UserLogin, UserModel, Token
from auth import verify_password, get_password_hash, create_access_token, get_current_user
from fastapi import Response

app = FastAPI()

# ---------------- CORS ----------------
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------------- STATIC FILES ----------------
os.makedirs("assets/generated", exist_ok=True)
app.mount("/static", StaticFiles(directory="assets/generated"), name="static")

# ---------------- AUTH ROUTES ----------------
@app.post("/register")
async def register(user: UserCreate):
    existing_user = await db.users.find_one({"email": user.email})
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    hashed_password = get_password_hash(user.password)
    user_dict = user.dict()
    user_dict["hashed_password"] = hashed_password
    del user_dict["password"]
    user_dict["colors"] = []
    
    new_user = await db.users.insert_one(user_dict)
    return {"message": "User created successfully", "id": str(new_user.inserted_id)}

@app.post("/login", response_model=Token)
async def login(user: UserLogin):
    db_user = await db.users.find_one({"email": user.email})
    if not db_user or not verify_password(user.password, db_user["hashed_password"]):
        raise HTTPException(status_code=401, detail="Incorrect email or password")
    
    access_token = create_access_token(data={"sub": user.email})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me", response_model=UserModel)
async def read_users_me(current_user: UserModel = Depends(get_current_user)):
    return current_user

@app.post("/colors")
async def add_color(color: str = Form(...), current_user: UserModel = Depends(get_current_user)):
    # Avoid duplicates
    if color not in current_user.colors:
        await db.users.update_one(
            {"_id": current_user.id},
            {"$push": {"colors": color}}
        )
    return {"message": "Color added", "colors": current_user.colors + [color] if color not in current_user.colors else current_user.colors}

@app.get("/cloud-images")
async def get_cloud_images(current_user: UserModel = Depends(get_current_user)):
    # Retrieve images generated by this user
    # We need to store them in DB first. Let's say collection 'images'
    cursor = db.images.find({"user_id": str(current_user.id)})
    images = await cursor.to_list(length=100)
    # Convert ObjectId to str
    for img in images:
        if "_id" in img:
            img["_id"] = str(img["_id"])
    return images

# ---------------- EXTRACT ----------------
@app.post("/extract")
async def extract(
    main_message: Optional[str] = Form(None),
    sub_message: Optional[str] = Form(None),
    cta_text: Optional[str] = Form(None),
    style: Optional[str] = Form("clean"),
    background_color: Optional[str] = Form(None),
    badge_color: Optional[str] = Form(None),
    badge_shape: Optional[str] = Form(None),
    tesco_tag: Optional[str] = Form(None),
    value_tile_type: Optional[str] = Form(None),
    clubcard_price: Optional[str] = Form(None),
    regular_price: Optional[str] = Form(None),
    clubcard_date: Optional[str] = Form(None),
):
    spec = {
        "main_message": main_message.strip() if main_message else "",
        "sub_message": sub_message.strip() if sub_message else "",
        "cta_text": cta_text.strip() if cta_text else "",
        "style": style.strip() if style else "clean",
        "background_color": background_color.strip() if background_color else None,
        "badge_color": badge_color.strip() if badge_color else None,
        "badge_shape": badge_shape.strip() if badge_shape else None,
        "tesco_tag": tesco_tag.strip() if tesco_tag else None,
        "value_tile_type": value_tile_type.strip() if value_tile_type else None,
        "clubcard_price": clubcard_price.strip() if clubcard_price else None,
        "regular_price": regular_price.strip() if regular_price else None,
        "clubcard_date": clubcard_date.strip() if clubcard_date else None,
    }
    return spec


# ---------------- GENERATE IMAGES ----------------
@app.post("/generate-images")
async def generate_images(
    spec: str = Form(...),
    product_image: UploadFile = Form(...),
    logo_image: UploadFile = Form(...),
    authorization: Optional[str] = Header(None) # Manual token extraction for mixed usage
):
    spec_dict = json.loads(spec)

    # Read Images
    product_bytes = await product_image.read()
    logo_bytes = await logo_image.read()
    
    product = Image.open(io.BytesIO(product_bytes)).convert("RGBA")
    logo = Image.open(io.BytesIO(logo_bytes)).convert("RGBA")

    # Generate for the REQUESTED spec (immediate return)
    primary_outputs = generate_all(
        spec=spec_dict,
        product=product,
        logo=logo,
    )

    # ---------------- DYNAMIC CLOUD GENERATION ----------------
    # Check if user is authenticated
    user = None
    if authorization:
        try:
            scheme, param = authorization.split()
            if scheme.lower() == 'bearer':
                user = await get_current_user(param)
        except Exception:
            pass # Invalid token, ignore
    
    if user:
        # User is logged in. 
        # Requirement: "generated from all that colors stored... viewd in cloud url"
        stored_colors = user.colors
        
        # Also include the current requested color if not in stored? 
        # Requirement says "generated from all that colors stored".
        # We'll iterate through stored colors.
        # Combine stored colors with the current requested color to ensure cloud history is populated
        unique_colors = set(stored_colors)
        current_bg = spec_dict.get("background_color")
        if current_bg:
            unique_colors.add(current_bg)
        
        print(f"DEBUG: User {user.email} found. Generataing for colors: {unique_colors}")
        
        for color in unique_colors:
            # Create a localized spec
            color_spec = spec_dict.copy()
            color_spec["background_color"] = color
            
            # Generate
            color_outputs = generate_all(color_spec, product, logo)
            
            # Identify this batch
            batch_id = str(uuid.uuid4())
            
            # Save to disk and DB
            for fmt, file_map in color_outputs.items():
                if fmt == "validation":
                    continue
                
                # file_map is {'png': ..., 'jpg': ...}
                stored_urls = {}
                
                for ext, b64_data in file_map.items():
                    img_data = base64.b64decode(b64_data)
                    filename = f"{user.id}_{uuid.uuid4()}.{ext}"
                    path = os.path.join("assets", "generated", filename)
                    
                    with open(path, "wb") as f:
                        f.write(img_data)
                    
                    stored_urls[ext] = f"http://127.0.0.1:8000/static/{filename}"
                
                # Save metadata to DB
                # Group: user_id + batch_id
                await db.images.insert_one({
                    "user_id": str(user.id),
                    "batch_id": batch_id,
                    "urls": stored_urls, # {png: url, jpg: url}
                    "format": fmt,
                    "color": color,
                    "spec": color_spec,
                    "created_at": str(uuid.uuid1()) # Simple timestamp proxy or use ISO
                })

    return primary_outputs

# ---------------- AI GEN EXTENSION ----------------
@app.post("/ai-generate")
async def ai_generate_proxy(prompt: str = Form(...)):
    try:
        # Call the logic derived from AD-generator
        img_bytes = generate_ad_image(prompt)
        # Return directly as image
        return Response(content=img_bytes, media_type="image/jpeg")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
